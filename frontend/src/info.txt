installation:
npm init -y :: to create a package.json :to keep track of all dependencies
npm install express::to create a backend app(requires node)
nodemon (already installed: npm install -g nodemon)
mongoose: npm install mongoose (odm lib)


script(package.json):
"dev": "nodemon server.js"   to alternate the command
now:npm run dev

create .env file: to hide sensitive variable 
we will be adding this file in gitignore file
TO access it :npm install dotenv
dotenv loads env. variable into process.env object

API ENDPOINTS:

GET /resource : Gets all the resource documents

POST /resource : Creates a new resource document

GET /resource/:id : Gets a single resource document

DELETE /resource/:id : Deletes a single resource

PATCH /resource/:id : Updates a single resource


FRONTEND:
npm install react-router-dom

UPDATE/PATCH:  
I spent a lot of time  trying to figure out what I did wrong.
wrote the mongo updateWorkout express controller that returns this:
res.status(200).json(workout) , which is the old {object} before updating and not the new  
const workout = await workout.findOneAndUpdate({ _id: id }, {...req.body}, {new: true})
Update Form:  Now, when you write the onSubmit handler fetch, 
you can use the  json = await response.json() from server to update useContext dispatch (#12).

workoutContext.js Switch Case "UPDATE_WORKOUT":  
return {workouts: state.workouts.map((workout) =>  
workout._id === action.payload._id ? action.payload : workout)}